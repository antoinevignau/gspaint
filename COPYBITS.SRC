;======================================================;;                                                      ;;              C O P Y B I T S                         ;;                                                      ;;======================================================;Copybits       start               Using DataSrc_PixMap     Equ  18Dst_PixMap     Equ  40PortScb        Equ  0                   Deplacement dans un LocInfoImageRef       Equ  PortScb+2Width          Equ  ImageRef+4BoundsRect     Equ  Width+2PPSrcLoc       Equ  0                   Deplacement dans les Parm du PaintPixPPDstLoc       Equ  PPSrcLoc+4PPSrcRect      Equ  PPDstLoc+4PPDstRect      Equ  PPSrcRect+4               Plx               Pla               Sta  Ptr10               Pla               Sta  Ptr10+2               Phx               Ldy  #PPSrcLoc           Traite  SrcLoc               Lda  [Ptr10],y               Sta  Ptr14               Ldy  #PPSrcLoc+2               Lda  [Ptr10],y               Sta  Ptr14+2               Ldy  #ImageRef           Src_PixMap               Lda  [Ptr14],y               Sta  Src_PixMap               Ldy  #ImageRef+2               Lda  [Ptr14],y               Sta  Src_PixMap+2               Ldy  #Width              SrcRowByte               Lda  [Ptr14],y               Sta  SrcRowByte               Ldy  #PPDstLoc           Traite DstLoc               Lda  [Ptr10],y               Sta  Ptr14               Ldy  #PPDstLoc+2               Lda  [Ptr10],y               Sta  Ptr14+2               Ldy  #ImageRef           Dst_PixMap               Lda  [Ptr14],y               Sta  Dst_PixMap               Ldy  #ImageRef+2               Lda  [Ptr14],y               Sta  Dst_PixMap+2               Ldy  #Width              DstRowByte               Lda  [Ptr14],y               Sta  DstRowByte               Ldy  #PPSrcRect          SrcCBRect               Lda  [Ptr10],y               Sta  Ptr14               Ldy  #PPSrcRect+2               Lda  [Ptr10],y               Sta  Ptr14+2               Lda  [Ptr14]               Sta  SrcCBRect               Ldy  #2               Lda  [Ptr14],y               Sta  SrcCBRect+2               Ldy  #4               Lda  [Ptr14],y               Sta  SrcCBRect+4               Ldy  #6                        Lda  [Ptr14],y               Sta  SrcCBRect+6               Ldy  #PPDstRect          DstCBRect               Lda  [Ptr10],y               Sta  Ptr14               Ldy  #PPDstRect+2               Lda  [Ptr10],y               Sta  Ptr14+2               Lda  [Ptr14]               Sta  DstCBRect               Ldy  #2               Lda  [Ptr14],y               Sta  DstCBRect+2               Ldy  #4               Lda  [Ptr14],y               Sta  DstCBRect+4               Ldy  #6                        Lda  [Ptr14],y               Sta  DstCBRect+6               lda srcCBrect+6               sec               sbc srcCBrect+2               sta src_hsize               lda dstCBrect+6               sec               sbc dstCBrect+2               sta dst_hsize               beq abort               lda srcCBrect+4               sec               sbc srcCBrect               sta src_vsize               lda dstCBrect+4               sec               sbc dstCBrect               sta dst_vsize               beq abort               lda src_hsize               bmi abort               lda dst_hsize               bmi abort               lda src_vsize               bmi abort               lda dst_vsize               bmi abort               jmp ok1abort          sec               rtsok1            anop               lda src_hsize               cmp dst_hsize               bge h_less               pushword #0              calculate quotient and remain               pushword #0               pushword dst_hsize               pushword src_hsize               _uDivide               pla               sta q_hpix               pla               asl a               sta rx2_hpix               lda #1               sta src_hblk               lda #0               sta h_mode               jmp init_vh_less         Anop               pushword #0              calculate quotient and remain               pushword #0               pushword src_hsize               pushword dst_hsize               _uDivide               pla               sta q_hpix               pla               asl a               sta rx2_hpix               lda #1               sta dst_hblk               lda #$ffff               sta h_modeinit_v         anop               lda src_vsize               cmp dst_vsize               bge v_less               pushword #0              calculate quotient and remain               pushword #0               pushword dst_vsize               pushword src_vsize               _uDivide               pla               sta q_vpix               pla               asl a               sta rx2_vpix               lda #1               sta src_vblk               lda #0               sta v_mode               jmp hvqr_doneV_Less         Anop               pushword #0              calculate quotient and remain               pushword #0               pushword src_vsize               pushword dst_vsize               _uDivide               pla               sta q_vpix               pla               asl a               sta rx2_vpix               lda #1               sta dst_vblk               lda #$ffff               sta v_mode*                                       we initialise the offsets now!*                                       src and dest regarding the*                                       locInfo, srcCBrect and dstCBrect.*                                       the offsets are initialised at*                                       the first pixel of their rect.*  src_offset = rowbyte*rect.top*2+rect.lefthvqr_done      anop               pushlong #0               pushword srcRowByte               pushword srcCBrect               _multiply               pla               asl a               tax               pla               txa               clc               adc srcCBrect+2               sta src_offset* same with dst_offset               pushlong #0               pushword dstRowByte               pushword dstCBrect               _multiply               pla               asl a               tax               pla               txa               clc               adc dstCBrect+2               sta dst_offset               lda #0               sta srcRow               sta dstRow               lda rx2_vpix               sta cur_vrnew_line       anop               lda v_mode               bmi svblk               lda q_vpix               sta dst_vblk               bra dvblksvblk          lda q_vpix               sta src_vblkdvblk          anop* test if we add one or not               lda cur_vr               bmi venough               bit v_mode               bmi svcalc               cmp src_vsize               blt venough               inc dst_vblk               lda cur_vr               sec               sbc src_vsize               sec                      twice because rx2               sbc src_vsize               sta cur_vr               jmp venoughsvcalc         cmp dst_vsize               blt venough               inc src_vblk               lda cur_vr               sec               sbc dst_vsize               sec                      twice because rx2               sbc dst_vsize               sta cur_vrvenough        lda cur_vr               clc               adc rx2_vpix               sta cur_vr                update the local remain               lda #0                   init the offset rect relatives               sta dstCol               sta srcCol               lda rx2_hpix               sta cur_hr* ok we are on the first pixels* calculate src_hblk et dst_hblknew_blk        anop               lda h_mode               bmi shblk               lda q_hpix               sta dst_hblk               bra dhblkshblk          lda q_hpix               sta src_hblkdhblk          anop* test if we add one or not               lda cur_hr               bmi henough               bit h_mode               bmi shcalc               cmp src_hsize               blt henough               inc dst_hblk               lda cur_hr               sec               sbc src_hsize               sec                      twice because rx2               sbc src_hsize               sta cur_hr               bra henoughshcalc         cmp dst_hsize               blt henough               inc src_hblk               lda cur_hr               sec               sbc dst_hsize               sec                      twice because rx2               sbc dst_hsize               sta cur_hrhenough        lda cur_hr               clc               adc rx2_hpix               sta cur_hr                update the local remain               jsr trans_blk* calculate next position               lda srcCol               clc                      to test border               adc srcCBrect+2          +left               cmp srcCBrect+6          compare right               blt new_blk* calculate the new offsets for the new line               ldx src_vblk               lda src_offsetx1             clc               adc srcrowbyte               adc srcrowbyte               dex               bne x1               sta src_offset               ldx dst_vblk               lda dst_offsetx2             clc               adc dstrowbyte               adc dstrowbyte               dex               bne x2               sta dst_offset               lda srcRow               clc               adc src_vblk               sta srcRow               lda dstRow               clc               adc dst_vblk               sta DstRow               clc               adc dstCBrect               cmp dstCBrect+4               bge done               brl new_linedone           clc               rtstrans_blk      entry*-----------------------------------------* transfert the block from src to dst*-----------------------------------------* we have the xxx_offset to                lda srccol               sta startcol               lda #0               sta ligne               lda #$000f               * sta color               sta colornew_hblk       ldx #0                   * count the src_hblk               lda startcol               sta srccolmore_src       lda src_offset               clc               adc srcCol*  calcule combien de ligne en plus               pha               ldy ligne               beq l0lx             clc               adc srcrowbyte               adc srcrowbyte               dey               bne lx               ply               phal0             pla               lsr a               tay               lda [src_pixmap],y               bcs odd               lsr a               lsr a               lsr a               lsr aodd            and #$000f               cmp color               bge new_x               sta colornew_x          inx               inc srcCol               cpx src_hblk               blt more_src               inc ligne               lda ligne               cmp src_vblk               blt new_hblk* at this point we got a point               * we need to move it back to more than one (maybe)               lda dstcol               sta startcol               lda #0               sta ligne               lda color               asl a               asl a               asl a               asl a               sta color2new_dblk       ldx #0               lda startcol               sta dstcolmore_dst       lda dst_offset               clc               adc dstCol               pha               ldy ligne               beq ll0llx            clc               adc dstrowbyte               adc dstrowbyte               dey               bne llx               ply6   TORONTO.9      ˆ ® G­( ã  G­;6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  inc ligne               lda ligne               cmp dst_vblk               blt new_dblk               rtscolor           ds 2color2          ds 2h_mode          ds 2v_mode          ds 2src_hsize       ds 2                     a in the algorithmdst_hsize       ds 2                     b in the algorithmsrc_vsize       ds 2                     a in the algorithmdst_vsize       ds 2                     b in the algorithmligne           ds 2startcol        ds 2src_hblk        ds 2                     a if a>b  !  q or q+1dst_hblk        ds 2                     q or q+1  !  b if b>asrc_vblk        ds 2                     a if a>b  !  q or q+1dst_vblk        ds 2                     q or q+1  !  b if b>aq_hpix          ds 2rx2_hpix        ds 2                     we work with twice the remaincur_hr          ds 2q_vpix          ds 2rx2_vpix        ds 2                     we work with twice the remaincur_vr          ds 2*                                       to comapre with 1 rather than .5*                                       this means we have to substract*                                       (2x q.pix) rather than q.pixsrc_offset     ds 2                     offsets in pixel in the bitmapsdst_offset     ds 2srcCol         ds 2                     offsets in pixel in a linedstCol         ds 2                     and rect relativesrcRow         ds 2dstRow         ds 2SrcRowByte     ds   2DstRowByte     ds   2srcCBrect      ds   8dstCBrect      ds   8               end