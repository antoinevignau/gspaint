;======================================================;;                                                      ;;              R E A D D I R                           ;;                                                      ;;======================================================;ReadDir        start               Using Anime_data               Using Data               ldx #22               lda #0clrdos         anop               sta >$00bf58,x               dex               dex               bne clrdos               lda     #01               sta     EntryNum         ; EntryNum = 1.               stz     NumFiles         ; 0 files found.               _GetPrefix ParSetPref               _Open ParOpen               bcc     *+4               brk     $10               lda     ParOpen               sta     RefNumb               sta     ParSkip               _SetMark ParSkip               bcc     *+4               brk     $16Loop           jsr     ReadAnEntry               bcs     Error               jsr     ValidEntry               beq     Loop               jsr     InsertEntry               bra     LoopError          anop               cmp     #$4C               beq     EofOnly               brk     $12EofOnly        Anop               _Close ParOpen               lda     NumFiles               bne     OneFile               lda     #-1              ; no file selected.               sta     CurFileOneFile        rtsParOpen        dc      i'00'            ; Refnumb output.               dc      i4'dirname'           ; Pathname Pointer.               dc      i4'00'           ; File's Buffer Output.ParSkip        dc      i'00'            ; Refnumb.               dc      i4'4+$27'        ; Position.ParSetPref     dc      i'00'            ; Prefix Number               dc      i4'dirname'           ; Pathname Pointer.;------------------------------------------------;; Read a Valid Entry (not deleted) in the file; opened with  Refnumb. Store this Entry; in hAnEntry.;; Output : Carry Set if Error while reading,;          A = Error Code.;------------------------------------------------ReadAnEntry    EntryMaxEntry       equ     $0D             ; Number of entries in a bloc.               PushLong hAnEntry        ; Lock the Handle where               _HLock                   ; we read the Entry.               ldy     #02               lda     [hAnEntry]       ; Dereference the Handle,               sta     Scr1             ; and put the Pointer in               sta     AdrRead          ; Scr1 and AdrRead.               lda     [hAnEntry],Y               sta     Scr1+2               sta     AdrRead+2               lda     RefNumb               sta     ParReadReadNext1      lda     EntryNum         ; Is it the last Entry ?               cmp     #MaxEntry               bcc     ReadNext         ; No, read Next               stz     EntryNum         ; EntryNum = 0.               lda     #05              ; Yes, Skip 5 bytes.               sta     CountRead               _Read   ParRead               ldx     #$27             ; Restore Entry Length.               stx     CountRead               bcs     BadReadReadNext       Anop               _Read   ParRead               bcs     BadRead          ; If Error, then Stop.               inc     EntryNum               lda     [Scr1]           ; Get File Type.               and     #$000F           ; Entry deleted ?               beq     ReadNext1GoodRead       lda     #00BadRead        anop               php                      ; Save status and A.               pha               PushLong hAnEntry        ; Unlock the handle now.               _HUnlock               pla                      ; Restore A and Status.               plp               rtsParRead        dc      i'00'            ; RefNumb.AdrRead        dc      i4'0'            ; Adress where we read.CountRead      dc      i4'$27'          ; Entry's Length.               dc      i4'00'           ; Transfer Count.;------------------------------------------------;;  Function which determines if "hAnEntry" will;  be displayed or not. The result is on;  the stack.;;------------------------------------------------ ValidEntry     EntryTypeFile       equ     Scr0               jsr     EntryhTop        ; Derefence hAnEntry.               sep #$30               longa off               longi off               ldy mantissemore4          lda mantisse,y               and #$7f               cmp #'a'               blt upper               and #$5fupper          Anop               cmp [pAnEntry],y               bne bad               dey               bne more4* test le type               ldy #$10               lda [pAnEntry],y               cmp #$6               beq G1               cmp #$c0               beq g1               cmp #$c1               bne Badg1             ldy mantisse               iny               lda [pAnEntry],y               and #$7f               cmp #$30               blt bad               cmp #$3a               bge bad               longa on               longi on               rep #$30               lda #$ffff               good               rtsBad            rep #$30               lda #$00                 bad               rts;------------------------------------------------;;  Procedure which inserts the Entry "hAnEntry";  in "hAllEntry" in alphabetical order.;;  Output : Carry set if Error;           A : Error code.;------------------------------------------------ InsertEntry    EntryLongr          equ     Scr1               jsr     EntryhTop        ; dereferences the Handles.               jsr     AllhTop               lda     [pAnEntry]       ; Remove Storage Type.               and     #$FF0F               sta     [pAnEntry]               lda     pAllEntry        ; Save Pointer on AllEntry               sta     Scr0             ; in Scr0               lda     pAllEntry+2               sta     Scr0+2               ldx     #00              ; Begin with first Entry.BigLoop        cpx     NumFiles         ; Is it the last file ?               bcs     Found               sep     #$30             ; 8 bits mode.               longa   Off               longi   Off               lda     [Scr0]           ; Find shorter length.               cmp     [pAnEntry]               bcc     TryNext               bne     found               lda     [pAnEntry]ll0            ina                      ; Longr +1 for future Tests.               sta     Longr               ldy     #01              ; Begin with first Char.LoopCmp        lda     [Scr0],Y               cmp     #'a'             ; put it in Upper-Case               bcc     NotLower         ; if necessary.               and     #%11011111NotLower       cmp     [pAnEntry],Y     ; compare with current               bcc     TryNext          ; entry. If <, take next               bne     Found            ; entry, if > it's the good.               iny                      ; tests the next char.               cpy     Longr               bcc     LoopCmp               lda     [Scr0]           ; if strings are identics,               cmp     [pAnEntry]       ; tests lengths.               bcs     FoundTryNext        rep     #$30             ; back in native mode.               longa   On               longi   On               lda     Scr0             ; Take next entry by adding               clc                      ; Entry's length to Pointer.               adc     #LenEntry               sta     Scr0               bcc     CarryClr               inc     Scr0+2CarryClr       inx                      ; and do it again.               bra     BigLoopFound          rep     #$30             ; stil in native mode.               longa   On               longi   On               inc     NumFiles         ; Numfiles = NumFiles+1               lda     Scr0             ; get offset of the Entry               sec                      ; found in the Array.               sbc     pAllEntry               sta     Scr0               lda     Scr0+2               sbc     pAllEntry+2               sta     Scr0+2               PushLong #00             ; get length of the Array.               PushLong hAllEntry               _GetHandleSize               pla                      ; and store it in Scr1.               sta     Scr1               plx               stx     Scr1+2               clc               adc     #LenEntry        ; size handle to current               bcc     ll1              ; size + LenEntry.               inxll1            phx               pha               PushLong hAllEntry               _SetHandleSize               bcc     *+4               brk     00               jsr     AllhTop          ; dereferences handle.               lda     pAllEntry        ; get adress of the entry               clc                      ; found by adding the               adc     Scr0             ; offset Scr0.               pha               lda     pAllEntry+2               adc     Scr0+2               tax                      ; push this adress twice for               pla                      ; future use.               phx                      ; Source.               pha               phx               pha               clc               adc     #LenEntry        ; Dest = org + LenEntry               bcc     *+3               inx               phx                      ; Dest.               pha               lda     Scr1             ; Count = OldSize- Offset.               sec               sbc     Scr0               tax               lda     Scr1+2               sbc     Scr0+2               bne     NoNull               cpx     #00               beq     Null             ; if Count = 0, no BlockMove.NoNull         pha                      ; Count.               phx               _BlockMove               bra     ComonNull           pla                      ; pull non-used parameters.               pla               pla               plaComon          lda     pAnEntry         ; Convert Name               ldy     pAnEntry+2               pla                      ; Pull adress of the new               sta     Scr0             ; entry.               plx               stx     Scr0+2               jsr     EntryhTop        ; dereferences handle.               ldy     #16              ; and copy the Entry in theCopy           lda     [pAnEntry],Y     ; Array with its Type.               sta     [Scr0],Y               dey               dey               bpl     Copy               rtsEntryhTop      Entry               ldy     #02               lda     [hAnEntry]       ; Dereference the Handle,               sta     pAnEntry         ; and put the Pointer in               lda     [hAnEntry],Y     ; pAnEntry.               sta     pAnEntry+2               rtsAllhTop        Entry               ldy     #02               lda     [hAllEntry]      ; Dereference the Handle,               sta     pAllEntry        ; and put the Pointer in               lda     [hAllEntry],Y    ; pAllEntry.               sta     pAllEntry+2               rtsCreateHandles  Entry               PushLong #00             ; Output : Handle.               PushLong #00             ; Block Size.               PushWord MyID            ; Owner.               PushWord #00             ; not purgeable !               PushLong #00             ; Anywhere.               _NewHandle               bcc     *+4               brk     02               pla               sta     hAllEntry               pla               sta     hAllEntry+2               PushLong #00             ; Output : Handle.               PushLong #$28            ; Block Size for an Entry.               PushWord MyID            ; Owner.               PushWord #00             ; not purgeable !               PushLong #00             ; Anywhere.               _NewHandle               bcc     *+4               brk     02               pla               sta     hAnEntry               pla               sta     hAnEntry+2               rtsRemoveHandles  Entry               pushlong hAllEntry               _hunlock               pushlong hAllEntry               _disposehandle               pushlong hANEntry               _hunlock               pushlong hANEntry               _disposehandle               rts               end